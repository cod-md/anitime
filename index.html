<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Anime Character Timeline Canvas</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            overscroll-behavior: none;
            touch-action: none;
        }
        #canvas-container {
            cursor: grab;
            /* background-size is now set via JS to allow zooming */
            transition: background-image 0.3s ease-in-out;
        }
        #canvas-container:active {
            cursor: grabbing;
        }
        #canvas {
            transform-origin: 0 0;
        }
        .character-on-canvas {
            cursor: move;
            position: absolute;
            width: 70px;
            height: 70px;
            display: flex;
            align-items: center;
            justify-content: center;
            user-select: none;
            transition: top 0.1s ease-out, left 0.1s linear;
            z-index: 10;
        }
        /* Disable transition during active drag to prevent lag */
        .character-on-canvas.dragging {
            transition: none;
        }
        .character-on-canvas img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            border-radius: 0.5rem; 
            border: 3px solid white;
            box-shadow: 0 4px 10px rgba(0,0,0,0.3);
            pointer-events: none;
        }
        
        .timeline-svg {
            position: absolute;
            top: 0;
            left: 0;
            overflow: visible;
            pointer-events: none;
            z-index: 1;
        }

        .character-on-canvas.reposition-mode {
            border-radius: 0.5rem; /* Match the image radius */
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% {
                box-shadow: 0 0 0 0 rgba(59, 130, 246, 0.7); /* blue-500 */
            }
            70% {
                box-shadow: 0 0 0 10px rgba(59, 130, 246, 0);
            }
            100% {
                box-shadow: 0 0 0 0 rgba(59, 130, 246, 0);
            }
        }

        #character-list-container{
             touch-action: pan-x;
        }
        .character-list-item {
            cursor: grab;
            transition: transform 0.2s;
            touch-action: none;
        }
        .character-list-item:active {
            cursor: grabbing;
            transform: scale(1.1);
        }
        #ghost-element {
            position: fixed;
            pointer-events: none;
            opacity: 0.7;
            z-index: 1000;
            transform: scale(1.1);
        }
        .toast {
            visibility: hidden;
            opacity: 0;
            transition: opacity 0.5s, visibility 0.5s;
        }
        .toast.show {
            visibility: visible;
            opacity: 1;
        }
        .delete-char-btn {
            position: absolute;
            top: -8px;
            right: -8px;
            width: 24px;
            height: 24px;
            background-color: #ef4444; /* red-500 */
            color: white;
            border-radius: 50%;
            display: none;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            font-weight: bold;
            line-height: 1;
            cursor: pointer;
            border: 2px solid white;
            z-index: 11;
        }
        .character-on-canvas:hover .delete-char-btn {
            display: flex;
        }
        #timeline-mode-btn.active {
            background-color: #4f46e5; /* indigo-600 */
            color: white;
        }
    </style>
</head>
<body class="bg-gray-100 dark:bg-gray-900 text-gray-800 dark:text-gray-200 h-screen w-screen overflow-hidden flex flex-col transition-colors duration-300">

    <!-- Main Canvas Area -->
    <div id="canvas-container" class="relative w-full h-full flex-grow overflow-hidden bg-white dark:bg-gray-800">
        <div id="canvas" class="absolute top-0 left-0">
            <!-- Timelines (SVG) and Characters will be added here -->
        </div>
        <button id="timeline-mode-btn" title="Toggle Timeline Drawing Mode" class="absolute top-4 left-4 z-20 p-3 bg-white dark:bg-gray-700 rounded-full shadow-lg hover:bg-gray-100 dark:hover:bg-gray-600 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 transition-colors duration-200">
            <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>
        </button>
        <div id="drop-overlay" class="absolute inset-0 bg-gray-900 bg-opacity-50 hidden items-center justify-center pointer-events-none z-50">
            <div class="text-center p-10 border-4 border-dashed border-white rounded-lg">
                <p class="text-white text-2xl font-bold">Drop your JSON file here to load</p>
            </div>
        </div>
    </div>

    <!-- Bottom Control Panel -->
    <div class="bg-gray-50 dark:bg-gray-950 border-t border-gray-200 dark:border-gray-800 shadow-lg p-2 md:p-3 w-full z-10 flex-shrink-0 transition-colors duration-300">
        <div class="max-w-7xl mx-auto">
             <div class="flex justify-between items-center">
                <details class="bg-white dark:bg-gray-900 rounded-lg border border-gray-200 dark:border-gray-700 flex-grow">
                    <summary class="p-2 cursor-pointer font-bold text-center text-gray-700 dark:text-gray-300">Add New Character</summary>
                    <form id="add-character-form" class="flex flex-col md:flex-row items-center gap-3 p-3 border-t border-gray-200 dark:border-gray-700">
                        <input type="text" id="char-name" placeholder="Character Name" class="bg-gray-100 dark:bg-gray-800 border border-gray-300 dark:border-gray-600 text-gray-900 dark:text-gray-100 p-2 rounded-md w-full md:w-auto flex-grow focus:ring-2 focus:ring-indigo-500" required>
                        <div class="flex items-center gap-2">
                             <label for="char-image" class="cursor-pointer bg-indigo-600 hover:bg-indigo-700 text-white p-2 rounded-md text-sm whitespace-nowrap">Choose Image</label>
                            <input type="file" id="char-image" accept="image/*" class="hidden" required>
                            <span id="file-name" class="text-xs text-gray-500 dark:text-gray-400 max-w-[100px] truncate">No file chosen</span>
                        </div>
                        <div class="flex items-center gap-2">
                            <label for="char-color" class="text-sm">Color</label>
                            <input type="color" id="char-color" value="#ff0000" class="w-10 h-10 rounded-md border-2 border-gray-200 dark:border-gray-700 cursor-pointer">
                        </div>
                        <button type="submit" class="bg-green-600 hover:bg-green-700 text-white p-2 rounded-md font-bold w-full md:w-auto">Add</button>
                    </form>
                </details>
                <div class="flex items-center ml-3">
                    <button id="download-btn" type="button" class="p-2 rounded-lg text-gray-500 dark:text-gray-400 hover:bg-gray-200 dark:hover:bg-gray-700 focus:outline-none focus:ring-2 focus:ring-gray-300 dark:focus:ring-gray-600" title="Download Timeline">
                        <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4"></path></svg>
                    </button>
                    <button id="theme-toggle" type="button" class="p-2 rounded-lg text-gray-500 dark:text-gray-400 hover:bg-gray-200 dark:hover:bg-gray-700 focus:outline-none focus:ring-2 focus:ring-gray-300 dark:focus:ring-gray-600">
                        <svg id="theme-toggle-dark-icon" class="hidden w-6 h-6" fill="currentColor" viewBox="0 0 20 20"><path d="M17.293 13.293A8 8 0 016.707 2.707a8.001 8.001 0 1010.586 10.586z"></path></svg>
                        <svg id="theme-toggle-light-icon" class="hidden w-6 h-6" fill="currentColor" viewBox="0 0 20 20"><path d="M10 2a1 1 0 011 1v1a1 1 0 11-2 0V3a1 1 0 011-1zm4 8a4 4 0 11-8 0 4 4 0 018 0zm-.464 4.95l.707.707a1 1 0 001.414-1.414l-.707-.707a1 1 0 00-1.414 1.414zm2.121-3.536a1 1 0 010 1.414l-.707.707a1 1 0 11-1.414-1.414l.707-.707a1 1 0 011.414 0zM10 16a1 1 0 011 1v1a1 1 0 11-2 0v-1a1 1 0 011-1zm-4.464-3.05a1 1 0 00-1.414 1.414l.707.707a1 1 0 001.414-1.414l-.707-.707zm-2.121-3.536a1 1 0 01.707-.293h1.414a1 1 0 110 2H4.222a1 1 0 01-.707-1.707z" fill-rule="evenodd" clip-rule="evenodd"></path></svg>
                    </button>
                </div>
            </div>

            <div id="character-list-container" class="mt-2 bg-white dark:bg-gray-900 p-2 rounded-lg border border-gray-200 dark:border-gray-700 transition-colors duration-300">
                <h3 class="text-center font-semibold text-sm mb-2 text-gray-600 dark:text-gray-400">Character List (Drag a character to the canvas)</h3>
                 <div id="character-list" class="flex gap-4 overflow-x-auto p-2 min-h-[90px] items-center justify-start">
                     <p id="empty-list-msg" class="text-gray-500 w-full text-center">No characters added yet.</p>
                 </div>
            </div>
        </div>
    </div>

    <div id="toast" class="toast fixed bottom-5 right-5 bg-red-500 text-white py-2 px-4 rounded-lg shadow-lg z-20">
        <p id="toast-message"></p>
    </div>

<script>
    document.addEventListener('DOMContentLoaded', () => {
        const canvasContainer = document.getElementById('canvas-container');
        const canvas = document.getElementById('canvas');
        const addCharacterForm = document.getElementById('add-character-form');
        const charNameInput = document.getElementById('char-name');
        const charImageInput = document.getElementById('char-image');
        const charColorInput = document.getElementById('char-color');
        const characterList = document.getElementById('character-list');
        const fileNameSpan = document.getElementById('file-name');
        const emptyListMsg = document.getElementById('empty-list-msg');
        const toast = document.getElementById('toast');
        const toastMessage = document.getElementById('toast-message');
        const downloadBtn = document.getElementById('download-btn');
        const dropOverlay = document.getElementById('drop-overlay');
        const timelineModeBtn = document.getElementById('timeline-mode-btn');

        const SHELF_HEIGHT = 100;
        const CHARACTER_SIZE = 70;
        const CHARACTER_HALF_SIZE = CHARACTER_SIZE / 2;

        let characters = [];
        let pan = { x: 0, y: 0 };
        let scale = 1;
        const MIN_SCALE = 0.2;
        const MAX_SCALE = 4;

        let isPanning = false;
        let panStartPoint = { x: 0, y: 0 };
        let activeDrag = null;
        let listDrag = null;
        let isPinching = false;
        let initialPinchDistance = 0;
        let isTimelineModeActive = false;
        
        function updateTransform() {
            canvas.style.transform = `translate(${pan.x}px, ${pan.y}px) scale(${scale})`;
            canvasContainer.style.backgroundPosition = `${pan.x}px ${pan.y}px`;
            canvasContainer.style.backgroundSize = `100% ${SHELF_HEIGHT * scale}px`;
        }

        function getEventCoords(e) {
            return e.touches ? { x: e.touches[0].clientX, y: e.touches[0].clientY } : { x: e.clientX, y: e.clientY };
        }

        function generatePathD(points) {
            if (!points || points.length === 0) return "";
            const start = `M ${points[0].x} ${points[0].y}`;
            const rest = points.slice(1).map(p => `L ${p.x} ${p.y}`).join(' ');
            return `${start} ${rest}`;
        }

        // --- DRAG LOGIC ---

        function dragCharacterStart(e, charElement) {
            e.stopPropagation();

            let currentMode = 'none';

            if (isTimelineModeActive) {
                currentMode = 'timeline';
            } 
            else if (charElement.classList.contains('reposition-mode') || !charElement.timeline) {
                currentMode = 'reposition';
            }

            if (currentMode === 'none') {
                return;
            }

            charElement.classList.add('dragging');

            if (currentMode === 'timeline' && !charElement.timeline) {
                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                path.setAttribute('stroke', charElement.dataset.color);
                path.setAttribute('stroke-width', '12');
                path.setAttribute('stroke-linecap', 'round');
                path.setAttribute('stroke-linejoin', 'round');
                path.setAttribute('fill', 'none');
                const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                svg.classList.add('timeline-svg');
                svg.appendChild(path);
                canvas.insertBefore(svg, canvas.firstChild);
                const startPos = { x: parseFloat(charElement.style.left) + CHARACTER_HALF_SIZE, y: parseFloat(charElement.style.top) + CHARACTER_HALF_SIZE };
                charElement.timeline = { svg: svg, path: path, points: [startPos] };
                path.setAttribute('d', generatePathD([startPos, startPos])); 
            }
            
            const coords = getEventCoords(e);
            const rect = charElement.getBoundingClientRect();

            activeDrag = {
                element: charElement,
                timeline: charElement.timeline,
                offsetX: (coords.x - rect.left) / scale,
                offsetY: (coords.y - rect.top) / scale,
                lastPreviewPoints: charElement.timeline ? [...charElement.timeline.points] : null,
                mode: currentMode,
                originalTop: parseFloat(charElement.style.top),
                originalLeft: parseFloat(charElement.style.left),
                originalPoints: charElement.timeline ? [...charElement.timeline.points] : null
            };
        }

        function dragCharacterMove(e) {
            if (!activeDrag) return;
            e.preventDefault();
            const coords = getEventCoords(e);
            const containerRect = canvasContainer.getBoundingClientRect();
            const currentX = (coords.x - containerRect.left - pan.x) / scale;
            const currentY = (coords.y - containerRect.top - pan.y) / scale;
            
            if (activeDrag.mode === 'timeline') {
                let newLeft = currentX - activeDrag.offsetX;
                const rawTop = currentY - activeDrag.offsetY;
                const snappedShelfY = Math.round((rawTop + CHARACTER_SIZE) / SHELF_HEIGHT) * SHELF_HEIGHT;
                const snappedTop = snappedShelfY - CHARACTER_SIZE;
                
                const lastCommittedPoint = activeDrag.timeline.points[activeDrag.timeline.points.length - 1];
                const lastCommittedLeft = lastCommittedPoint.x - CHARACTER_HALF_SIZE;
                newLeft = Math.max(newLeft, lastCommittedLeft);
                
                activeDrag.element.style.left = `${newLeft}px`;
                activeDrag.element.style.top = `${snappedTop}px`;
                
                const currentPos = { x: newLeft + CHARACTER_HALF_SIZE, y: snappedTop + CHARACTER_HALF_SIZE };
                let previewPoints = [...activeDrag.timeline.points];
                const lastCorner = previewPoints[previewPoints.length - 1];
                if (currentPos.y !== lastCorner.y) {
                    previewPoints.push({ x: lastCorner.x, y: currentPos.y });
                }
                previewPoints.push(currentPos);
                if (previewPoints.length > 1) {
                    const last = previewPoints[previewPoints.length - 1];
                    const secondLast = previewPoints[previewPoints.length - 2];
                    if (last.x === secondLast.x && last.y === secondLast.y) {
                        previewPoints.pop();
                    }
                }
                activeDrag.timeline.path.setAttribute('d', generatePathD(previewPoints));
                activeDrag.lastPreviewPoints = previewPoints;

            } else if (activeDrag.mode === 'reposition') {
                const newLeft = currentX - activeDrag.offsetX;
                const rawTop = currentY - activeDrag.offsetY;
                const snappedShelfY = Math.round((rawTop + CHARACTER_SIZE) / SHELF_HEIGHT) * SHELF_HEIGHT;
                const snappedTop = snappedShelfY - CHARACTER_SIZE;

                const deltaX = newLeft - activeDrag.originalLeft;
                const deltaY = snappedTop - activeDrag.originalTop;
                
                activeDrag.element.style.left = `${newLeft}px`;
                activeDrag.element.style.top = `${snappedTop}px`;

                // Only move timeline path if it exists
                if (activeDrag.timeline) {
                    const newPoints = activeDrag.originalPoints.map(p => ({
                        x: p.x + deltaX,
                        y: p.y + deltaY
                    }));

                    activeDrag.timeline.path.setAttribute('d', generatePathD(newPoints));
                    activeDrag.lastPreviewPoints = newPoints;
                }
            }
        }

        function dragCharacterEnd() {
            if (!activeDrag) return;

            if (activeDrag.mode === 'reposition') {
                activeDrag.element.classList.remove('reposition-mode');
            }

            activeDrag.element.classList.remove('dragging');
            
            // Only update points if a timeline exists and was being modified
            if (activeDrag.timeline) {
                activeDrag.timeline.points = activeDrag.lastPreviewPoints;
            }
            
            activeDrag = null;
        }

        function onPointerDown(e) { 
            if (e.touches && e.touches.length === 2) { 
                isPanning = false; 
                isPinching = true; 
                initialPinchDistance = getPinchDistance(e); 
            } else if (e.target === canvasContainer || e.target === canvas) { 
                isPanning = true; 
                const coords = getEventCoords(e); 
                panStartPoint.x = coords.x - pan.x; 
                panStartPoint.y = coords.y - pan.y; 
                canvasContainer.style.cursor = 'grabbing';
                
                const repositionedChar = document.querySelector('.character-on-canvas.reposition-mode');
                if (repositionedChar) {
                    repositionedChar.classList.remove('reposition-mode');
                }
            } 
        }

        function onPointerMove(e) { if (isPinching && e.touches && e.touches.length === 2) { const newDist = getPinchDistance(e); const scaleFactor = newDist / initialPinchDistance; const oldScale = scale; scale = Math.max(MIN_SCALE, Math.min(MAX_SCALE, scale * scaleFactor)); const center = getPinchCenter(e); pan.x = center.x - (center.x - pan.x) * (scale / oldScale); pan.y = center.y - (center.y - pan.y) * (scale / oldScale); updateTransform(); initialPinchDistance = newDist; } else if (isPanning) { const coords = getEventCoords(e); pan.x = coords.x - panStartPoint.x; pan.y = coords.y - panStartPoint.y; updateTransform(); } else if (activeDrag) { dragCharacterMove(e); } }
        function onPointerUp(e) { if (isPinching && (!e.touches || e.touches.length < 2)) { isPinching = false; } if (isPanning) { isPanning = false; canvasContainer.style.cursor = 'grab'; } if (activeDrag) dragCharacterEnd(); }
        canvasContainer.addEventListener('wheel', (e) => { e.preventDefault(); const rect = canvasContainer.getBoundingClientRect(); const mouseX = e.clientX - rect.left; const mouseY = e.clientY - rect.top; const zoomFactor = 1.1; const oldScale = scale; scale = e.deltaY < 0 ? scale * zoomFactor : scale / zoomFactor; scale = Math.max(MIN_SCALE, Math.min(MAX_SCALE, scale)); pan.x = mouseX - (mouseX - pan.x) * (scale / oldScale); pan.y = mouseY - (mouseY - pan.y) * (scale / oldScale); updateTransform(); }, { passive: false });
        function getPinchDistance(e) { const dx = e.touches[0].clientX - e.touches[1].clientX; const dy = e.touches[0].clientY - e.touches[1].clientY; return Math.sqrt(dx * dx + dy * dy); }
        function getPinchCenter(e) { const rect = canvasContainer.getBoundingClientRect(); return { x: (e.touches[0].clientX + e.touches[1].clientX) / 2 - rect.left, y: (e.touches[0].clientY + e.touches[1].clientY) / 2 - rect.top, }; }
        canvasContainer.addEventListener('mousedown', onPointerDown);
        window.addEventListener('mousemove', onPointerMove);
        window.addEventListener('mouseup', onPointerUp);
        canvasContainer.addEventListener('touchstart', onPointerDown, { passive: false });
        window.addEventListener('touchmove', onPointerMove, { passive: false });
        window.addEventListener('touchend', onPointerUp);
        window.addEventListener('touchcancel', onPointerUp);
        
        timelineModeBtn.addEventListener('click', () => {
            isTimelineModeActive = !isTimelineModeActive;
            timelineModeBtn.classList.toggle('active', isTimelineModeActive);
            if (isTimelineModeActive) {
                document.querySelectorAll('.character-on-canvas.reposition-mode').forEach(el => el.classList.remove('reposition-mode'));
            }
        });

        function showToast(message){ toastMessage.textContent = message; toast.classList.add('show'); setTimeout(() => { toast.classList.remove('show'); }, 3000); }
        charImageInput.addEventListener('change', () => { fileNameSpan.textContent = charImageInput.files.length > 0 ? charImageInput.files[0].name : 'No file chosen'; });
        addCharacterForm.addEventListener('submit', (e) => { e.preventDefault(); const name = charNameInput.value; const color = charColorInput.value; const imageFile = charImageInput.files[0]; if (!name || !imageFile) { showToast("Please enter a name and choose an image for the character."); return; } const reader = new FileReader(); reader.onload = (event) => { characters.push({ id: Date.now(), name: name, color: color, imageUrl: event.target.result }); renderCharacterList(); addCharacterForm.reset(); fileNameSpan.textContent = 'No file chosen'; document.querySelector('details').open = false; }; reader.readAsDataURL(imageFile); });
        function renderCharacterList(){ characterList.innerHTML = ''; if (characters.length === 0) { emptyListMsg.style.display = 'block'; } else { emptyListMsg.style.display = 'none'; } characters.forEach(char => { const charDiv = document.createElement('div'); charDiv.className = 'flex flex-col items-center gap-1 character-list-item w-20 flex-shrink-0'; charDiv.draggable = true; charDiv.dataset.characterId = char.id; const img = document.createElement('img'); img.src = char.imageUrl; img.className = 'w-16 h-16 rounded-lg object-cover border-2'; img.style.borderColor = char.color; const nameSpan = document.createElement('span'); nameSpan.className = 'text-xs text-center truncate w-full'; nameSpan.textContent = char.name; charDiv.appendChild(img); charDiv.appendChild(nameSpan); charDiv.addEventListener('dragstart', (e) => e.dataTransfer.setData('text/plain', char.id)); charDiv.addEventListener('touchstart', (e) => { e.preventDefault(); startListDrag(e, charDiv, char.id); }, { passive: false }); characterList.appendChild(charDiv); }); }
        
        function createCharacterOnCanvas(character, x, y, restoredState = null) {
            const charElement = document.createElement('div');
            charElement.className = 'character-on-canvas';
            charElement.dataset.color = character.color;
            charElement.dataset.characterId = character.id;

            if (restoredState) {
                charElement.style.left = restoredState.left;
                charElement.style.top = restoredState.top;
            } else {
                const snappedShelfY = Math.round(y / SHELF_HEIGHT) * SHELF_HEIGHT;
                const snappedTop = snappedShelfY - CHARACTER_SIZE;
                charElement.style.left = `${x - CHARACTER_HALF_SIZE}px`;
                charElement.style.top = `${snappedTop}px`;
            }

            const img = document.createElement('img');
            img.src = character.imageUrl;
            img.style.borderColor = character.color;
            charElement.appendChild(img);

            const deleteBtn = document.createElement('button');
            deleteBtn.className = 'delete-char-btn';
            deleteBtn.innerHTML = '&times;';
            deleteBtn.addEventListener('click', (e) => {
                e.stopPropagation();
                // Remove timeline SVG
                if (charElement.timeline && charElement.timeline.svg) {
                    charElement.timeline.svg.remove();
                }
                // Remove character element
                charElement.remove();
                // Show character in the list again
                const listItem = document.querySelector(`.character-list-item[data-character-id='${character.id}']`);
                if (listItem) {
                    listItem.style.display = 'flex';
                }
            });
            charElement.appendChild(deleteBtn);

            canvas.appendChild(charElement);
            
            charElement.addEventListener('mousedown', (e) => dragCharacterStart(e, charElement));
            charElement.addEventListener('touchstart', (e) => dragCharacterStart(e, charElement), { passive: false });
            charElement.addEventListener('dblclick', (e) => {
                e.stopPropagation();
                document.querySelectorAll('.character-on-canvas.reposition-mode').forEach(el => {
                    if (el !== charElement) el.classList.remove('reposition-mode');
                });
                charElement.classList.toggle('reposition-mode');
            });

            if (restoredState && restoredState.timelinePoints && restoredState.timelinePoints.length > 1) {
                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                path.setAttribute('stroke', character.color);
                path.setAttribute('stroke-width', '12');
                path.setAttribute('stroke-linecap', 'round');
                path.setAttribute('stroke-linejoin', 'round');
                path.setAttribute('fill', 'none');
                path.setAttribute('d', generatePathD(restoredState.timelinePoints));
                const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                svg.classList.add('timeline-svg');
                svg.appendChild(path);
                canvas.insertBefore(svg, canvas.firstChild);
                charElement.timeline = { svg: svg, path: path, points: restoredState.timelinePoints };
            }

            if (!restoredState) {
                 const listItem = document.querySelector(`.character-list-item[data-character-id='${character.id}']`);
                if (listItem) {
                    listItem.style.display = 'none';
                }
            }
        }

        // --- SAVE/LOAD LOGIC ---
        function downloadCanvasState() {
            const canvasCharacters = [];
            document.querySelectorAll('.character-on-canvas').forEach(charElement => {
                canvasCharacters.push({
                    libId: parseInt(charElement.dataset.characterId),
                    left: charElement.style.left,
                    top: charElement.style.top,
                    timelinePoints: charElement.timeline ? charElement.timeline.points : []
                });
            });

            const state = {
                characterLibrary: characters,
                charactersOnCanvas: canvasCharacters,
                viewState: { pan, scale }
            };

            const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(state, null, 2));
            const downloadAnchorNode = document.createElement('a');
            downloadAnchorNode.setAttribute("href", dataStr);
            downloadAnchorNode.setAttribute("download", "anime_timeline.json");
            document.body.appendChild(downloadAnchorNode);
            downloadAnchorNode.click();
            downloadAnchorNode.remove();
        }

        function restoreCanvasState(state) {
            canvas.innerHTML = '';
            
            pan = state.viewState.pan;
            scale = state.viewState.scale;
            updateTransform();

            characters = state.characterLibrary;
            renderCharacterList();

            state.charactersOnCanvas.forEach(charState => {
                const character = characters.find(c => c.id === charState.libId);
                if (character) {
                    createCharacterOnCanvas(character, 0, 0, charState);
                }
            });

            // After restoring, hide the list items for characters on the canvas
            document.querySelectorAll('.character-on-canvas').forEach(charOnCanvas => {
                const id = charOnCanvas.dataset.characterId;
                const listItem = document.querySelector(`.character-list-item[data-character-id='${id}']`);
                if (listItem) {
                    listItem.style.display = 'none';
                }
            });
        }

        downloadBtn.addEventListener('click', downloadCanvasState);

        let dragCounter = 0;
        canvasContainer.addEventListener('dragenter', (e) => {
            if (e.dataTransfer.types.includes('Files')) {
                e.preventDefault();
                dragCounter++;
                dropOverlay.classList.remove('hidden');
                dropOverlay.classList.add('flex');
            }
        });
        canvasContainer.addEventListener('dragleave', (e) => {
            if (e.dataTransfer.types.includes('Files')) {
                e.preventDefault();
                dragCounter--;
                if (dragCounter === 0) {
                    dropOverlay.classList.add('hidden');
                    dropOverlay.classList.remove('flex');
                }
            }
        });
        canvasContainer.addEventListener('dragover', (e) => e.preventDefault());
        
        canvasContainer.addEventListener('drop', (e) => {
            e.preventDefault();
            
            // Always hide overlay and reset counter on any successful drop.
            dragCounter = 0;
            dropOverlay.classList.add('hidden');
            dropOverlay.classList.remove('flex');

            const charId = e.dataTransfer.getData('text/plain');
            if (charId) {
                const character = characters.find(c => c.id == charId);
                if (!character) return;
                const containerRect = canvasContainer.getBoundingClientRect();
                const x = (e.clientX - containerRect.left - pan.x) / scale;
                const y = (e.clientY - containerRect.top - pan.y) / scale;
                createCharacterOnCanvas(character, x, y);

            } else if (e.dataTransfer.files && e.dataTransfer.files.length > 0) {
                const file = e.dataTransfer.files[0];
                if (file.type === "application/json") {
                    const reader = new FileReader();
                    reader.onload = (event) => {
                        try {
                            const loadedState = JSON.parse(event.target.result);
                            if (loadedState.characterLibrary && loadedState.charactersOnCanvas && loadedState.viewState) {
                                restoreCanvasState(loadedState);
                            } else {
                                showToast("Invalid JSON file structure.");
                            }
                        } catch (err) {
                            showToast("Error parsing JSON file.");
                        }
                    };
                    reader.readAsText(file);
                } else {
                    showToast("Please drop a valid .json file.");
                }
            }
        });

        function startListDrag(e, element, charId) { const ghost = element.cloneNode(true); ghost.id = 'ghost-element'; document.body.appendChild(ghost); const coords = getEventCoords(e); ghost.style.left = `${coords.x - ghost.offsetWidth / 2}px`; ghost.style.top = `${coords.y - ghost.offsetHeight / 2}px`; listDrag = { ghost, charId }; window.addEventListener('touchmove', moveListDrag, { passive: false }); window.addEventListener('touchend', endListDrag, { once: true }); }
        function moveListDrag(e) { if (!listDrag) return; e.preventDefault(); const coords = getEventCoords(e); listDrag.ghost.style.left = `${coords.x - listDrag.ghost.offsetWidth / 2}px`; listDrag.ghost.style.top = `${coords.y - listDrag.ghost.offsetHeight / 2}px`; }
        function endListDrag(e) { if (!listDrag) return; window.removeEventListener('moveListDrag', moveListDrag); listDrag.ghost.remove(); const touch = e.changedTouches[0]; const dropTarget = document.elementFromPoint(touch.clientX, touch.clientY); if (dropTarget === canvasContainer || canvasContainer.contains(dropTarget)) { const character = characters.find(c => c.id == listDrag.charId); if (character) { const containerRect = canvasContainer.getBoundingClientRect(); const x = (touch.clientX - containerRect.left - pan.x) / scale; const y = (touch.clientY - containerRect.top - pan.y) / scale; createCharacterOnCanvas(character, x, y); } } listDrag = null; }

        // --- DARK MODE LOGIC ---
        const themeToggleBtn = document.getElementById('theme-toggle');
        const themeToggleDarkIcon = document.getElementById('theme-toggle-dark-icon');
        const themeToggleLightIcon = document.getElementById('theme-toggle-light-icon');

        function updateCanvasBackground() {
            if (document.documentElement.classList.contains('dark')) {
                canvasContainer.style.backgroundImage = 'linear-gradient(rgba(255, 255, 255, 0.1) 1px, transparent 1px)';
            } else {
                canvasContainer.style.backgroundImage = 'linear-gradient(rgba(0, 0, 0, 0.1) 1px, transparent 1px)';
            }
        }

        function updateToggleIcon() {
            if (document.documentElement.classList.contains('dark')) {
                themeToggleLightIcon.classList.remove('hidden');
                themeToggleDarkIcon.classList.add('hidden');
            } else {
                themeToggleDarkIcon.classList.remove('hidden');
                themeToggleLightIcon.classList.add('hidden');
            }
        }

        if (localStorage.getItem('theme') === 'dark' || (!('theme' in localStorage) && window.matchMedia('(prefers-color-scheme: dark)').matches)) {
            document.documentElement.classList.add('dark');
        } else {
            document.documentElement.classList.remove('dark');
        }
        updateCanvasBackground();
        updateToggleIcon();

        themeToggleBtn.addEventListener('click', () => {
            document.documentElement.classList.toggle('dark');
            if (document.documentElement.classList.contains('dark')) {
                localStorage.setItem('theme', 'dark');
            } else {
                localStorage.setItem('theme', 'light');
            }
            updateCanvasBackground();
            updateToggleIcon();
        });

        // --- Initial Render ---
        renderCharacterList();
        updateTransform();
    });
</script>

</body>
</html>

