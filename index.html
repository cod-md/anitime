<!DOCTYPE html>
<html lang="ar" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>لوحة الخط الزمني لشخصيات الأنمي</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Tajawal:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Tajawal', sans-serif;
            overscroll-behavior: none;
            touch-action: none;
        }
        #canvas-container {
            cursor: grab;
            /* UPDATED: White background with horizontal shelf lines */
            background-image: linear-gradient(rgba(0, 0, 0, 0.1) 1px, transparent 1px);
            background-size: 100% 100px; /* Shelf lines are 100px apart */
        }
        #canvas-container:active {
            cursor: grabbing;
        }
        #canvas {
            transform-origin: 0 0;
        }
        .character-on-canvas {
            cursor: move;
            position: absolute;
            width: 70px;
            height: 70px;
            display: flex;
            align-items: center;
            justify-content: center;
            user-select: none;
            transition: top 0.1s linear;
            z-index: 10;
        }
        .character-on-canvas img {
            width: 100%;
            height: 100%;
            object-fit: cover;
            border-radius: 50%;
            border: 3px solid white;
            box-shadow: 0 4px 10px rgba(0,0,0,0.3);
            pointer-events: none;
        }
        
        .timeline-svg {
            position: absolute;
            top: 0;
            left: 0;
            overflow: visible;
            pointer-events: none;
            z-index: 1;
        }

        #character-list-container{
             touch-action: pan-x;
        }
        .character-list-item {
            cursor: grab;
            transition: transform 0.2s;
            touch-action: none;
        }
        .character-list-item:active {
            cursor: grabbing;
            transform: scale(1.1);
        }
        #ghost-element {
            position: fixed;
            pointer-events: none;
            opacity: 0.7;
            z-index: 1000;
            transform: scale(1.1);
        }
        .toast {
            visibility: hidden;
            opacity: 0;
            transition: opacity 0.5s, visibility 0.5s;
        }
        .toast.show {
            visibility: visible;
            opacity: 1;
        }
    </style>
</head>
<body class="bg-gray-100 text-gray-800 h-screen w-screen overflow-hidden flex flex-col">

    <!-- Main Canvas Area -->
    <div id="canvas-container" class="relative w-full h-full flex-grow overflow-hidden bg-white">
        <div id="canvas" class="absolute top-0 left-0">
            <!-- Timelines (SVG) and Characters will be added here -->
        </div>
    </div>

    <!-- Bottom Control Panel -->
    <div class="bg-gray-50 border-t border-gray-200 shadow-lg p-2 md:p-3 w-full z-10 flex-shrink-0">
        <div class="max-w-7xl mx-auto">
            <details class="bg-white rounded-lg border border-gray-200">
                <summary class="p-2 cursor-pointer font-bold text-center text-gray-700">إضافة شخصية جديدة</summary>
                <form id="add-character-form" class="flex flex-col md:flex-row items-center gap-3 p-3 border-t border-gray-200">
                    <input type="text" id="char-name" placeholder="اسم الشخصية" class="bg-gray-100 border border-gray-300 text-gray-900 p-2 rounded-md w-full md:w-auto flex-grow focus:ring-2 focus:ring-indigo-500" required>
                    <div class="flex items-center gap-2">
                         <label for="char-image" class="cursor-pointer bg-indigo-600 hover:bg-indigo-700 text-white p-2 rounded-md text-sm whitespace-nowrap">اختر صورة</label>
                        <input type="file" id="char-image" accept="image/*" class="hidden" required>
                        <span id="file-name" class="text-xs text-gray-500 max-w-[100px] truncate">لم يتم اختيار ملف</span>
                    </div>
                    <div class="flex items-center gap-2">
                        <label for="char-color" class="text-sm">اللون</label>
                        <input type="color" id="char-color" value="#ff0000" class="w-10 h-10 rounded-md border-2 border-gray-200 cursor-pointer">
                    </div>
                    <button type="submit" class="bg-green-600 hover:bg-green-700 text-white p-2 rounded-md font-bold w-full md:w-auto">إضافة</button>
                </form>
            </details>

            <div id="character-list-container" class="mt-2 bg-white p-2 rounded-lg border border-gray-200">
                <h3 class="text-center font-semibold text-sm mb-2 text-gray-600">قائمة الشخصيات (اسحب شخصية إلى اللوحة)</h3>
                 <div id="character-list" class="flex gap-4 overflow-x-auto p-2 min-h-[90px] items-center justify-start">
                     <p id="empty-list-msg" class="text-gray-500 w-full text-center">لم تتم إضافة أي شخصيات بعد.</p>
                 </div>
            </div>
        </div>
    </div>

    <div id="toast" class="toast fixed bottom-24 right-4 bg-red-500 text-white py-2 px-4 rounded-lg shadow-lg z-20">
        <p id="toast-message"></p>
    </div>

<script>
    document.addEventListener('DOMContentLoaded', () => {
        const canvasContainer = document.getElementById('canvas-container');
        const canvas = document.getElementById('canvas');
        const addCharacterForm = document.getElementById('add-character-form');
        const charNameInput = document.getElementById('char-name');
        const charImageInput = document.getElementById('char-image');
        const charColorInput = document.getElementById('char-color');
        const characterList = document.getElementById('character-list');
        const fileNameSpan = document.getElementById('file-name');
        const emptyListMsg = document.getElementById('empty-list-msg');
        const toast = document.getElementById('toast');
        const toastMessage = document.getElementById('toast-message');

        const SHELF_HEIGHT = 100;
        const CHARACTER_SIZE = 70;
        const CHARACTER_HALF_SIZE = CHARACTER_SIZE / 2;

        let characters = [];
        let pan = { x: 0, y: 0 };
        let scale = 1;
        const MIN_SCALE = 0.2;
        const MAX_SCALE = 4;

        let isPanning = false;
        let panStartPoint = { x: 0, y: 0 };
        let activeDrag = null;
        let listDrag = null;
        let isPinching = false;
        let initialPinchDistance = 0;
        
        function updateTransform() {
            canvas.style.transform = `translate(${pan.x}px, ${pan.y}px) scale(${scale})`;
        }

        function getEventCoords(e) {
            return e.touches ? { x: e.touches[0].clientX, y: e.touches[0].clientY } : { x: e.clientX, y: e.clientY };
        }

        function generatePathD(points) {
            if (!points || points.length === 0) return "";
            const start = `M ${points[0].x} ${points[0].y}`;
            const rest = points.slice(1).map(p => `L ${p.x} ${p.y}`).join(' ');
            return `${start} ${rest}`;
        }

        // --- UPDATED DRAG AND TIMELINE LOGIC ---

        function dragCharacterStart(e, charElement) {
            e.stopPropagation();

            // Create timeline objects on the character's first drag
            if (!charElement.timeline) {
                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                path.setAttribute('stroke', charElement.dataset.color);
                path.setAttribute('stroke-width', '12');
                path.setAttribute('stroke-linecap', 'round');
                path.setAttribute('stroke-linejoin', 'round');
                path.setAttribute('fill', 'none');
                
                const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                svg.classList.add('timeline-svg');
                svg.appendChild(path);
                canvas.insertBefore(svg, canvas.firstChild);

                const startPos = {
                    x: parseFloat(charElement.style.left) + CHARACTER_HALF_SIZE,
                    y: parseFloat(charElement.style.top) + CHARACTER_HALF_SIZE
                };

                charElement.timeline = {
                    svg: svg,
                    path: path,
                    points: [startPos]
                };
            }
            
            const coords = getEventCoords(e);
            const rect = charElement.getBoundingClientRect();

            activeDrag = {
                element: charElement,
                timeline: charElement.timeline,
                offsetX: (coords.x - rect.left) / scale,
                offsetY: (coords.y - rect.top) / scale,
                lastPreviewPoints: [...charElement.timeline.points] // Start drag with a copy of existing points
            };
        }

        function dragCharacterMove(e) {
            if (!activeDrag) return;
            e.preventDefault();
            const coords = getEventCoords(e);
            const containerRect = canvasContainer.getBoundingClientRect();

            const currentX = (coords.x - containerRect.left - pan.x) / scale;
            const currentY = (coords.y - containerRect.top - pan.y) / scale;
            
            const newLeft = currentX - activeDrag.offsetX;
            const rawTop = currentY - activeDrag.offsetY;
            const snappedCenterY = Math.round((rawTop + CHARACTER_HALF_SIZE) / SHELF_HEIGHT) * SHELF_HEIGHT;
            const snappedTop = snappedCenterY - CHARACTER_HALF_SIZE;
            
            activeDrag.element.style.left = `${newLeft}px`;
            activeDrag.element.style.top = `${snappedTop}px`;

            const currentPos = {
                x: newLeft + CHARACTER_HALF_SIZE,
                y: snappedTop + CHARACTER_HALF_SIZE
            };

            let previewPoints = [...activeDrag.timeline.points];

            // --- Shrinking Logic: Remove points if dragging backward past corners ---
            while (previewPoints.length >= 2) {
                const p1 = previewPoints[previewPoints.length - 2];
                const p2 = previewPoints[previewPoints.length - 1];

                if (p1.y === p2.y) { // Last segment is horizontal
                    if (currentPos.y !== p1.y) break;
                    const dragDir = Math.sign(currentPos.x - p1.x);
                    const segmentDir = Math.sign(p2.x - p1.x);
                    if (dragDir !== segmentDir && segmentDir !== 0) {
                        previewPoints.pop();
                    } else { break; }
                } else { // Last segment is vertical
                    if (currentPos.x !== p1.x) break;
                    const dragDir = Math.sign(currentPos.y - p1.y);
                    const segmentDir = Math.sign(p2.y - p1.y);
                    if (dragDir !== segmentDir && segmentDir !== 0) {
                        previewPoints.pop();
                    } else { break; }
                }
            }

            // --- Extending Logic: Draw preview path from the last point ---
            const lastCorner = previewPoints[previewPoints.length - 1];
            
            if (currentPos.y !== lastCorner.y) {
                previewPoints.push({ x: lastCorner.x, y: currentPos.y });
            }
            previewPoints.push(currentPos);

            // Clean up duplicate points
            if (previewPoints.length > 1) {
                const last = previewPoints[previewPoints.length - 1];
                const secondLast = previewPoints[previewPoints.length - 2];
                if (last.x === secondLast.x && last.y === secondLast.y) {
                    previewPoints.pop();
                }
            }
            
            activeDrag.timeline.path.setAttribute('d', generatePathD(previewPoints));
            activeDrag.lastPreviewPoints = previewPoints;
        }

        function dragCharacterEnd() {
            if (!activeDrag) return;

            // Commit the final calculated points to the character's permanent timeline
            activeDrag.timeline.points = activeDrag.lastPreviewPoints;
            activeDrag.timeline.path.setAttribute('d', generatePathD(activeDrag.timeline.points));
            
            activeDrag = null;
        }

        // --- Global Event Handlers for Pan, Zoom, and Drag (unchanged) ---
        function onPointerDown(e) { if (e.touches && e.touches.length === 2) { isPanning = false; isPinching = true; initialPinchDistance = getPinchDistance(e); } else if (e.target === canvasContainer || e.target === canvas) { isPanning = true; const coords = getEventCoords(e); panStartPoint.x = coords.x - pan.x; panStartPoint.y = coords.y - pan.y; canvasContainer.style.cursor = 'grabbing'; } }
        function onPointerMove(e) { if (isPinching && e.touches && e.touches.length === 2) { const newDist = getPinchDistance(e); const scaleFactor = newDist / initialPinchDistance; const oldScale = scale; scale = Math.max(MIN_SCALE, Math.min(MAX_SCALE, scale * scaleFactor)); const center = getPinchCenter(e); pan.x = center.x - (center.x - pan.x) * (scale / oldScale); pan.y = center.y - (center.y - pan.y) * (scale / oldScale); updateTransform(); initialPinchDistance = newDist; } else if (isPanning) { const coords = getEventCoords(e); pan.x = coords.x - panStartPoint.x; pan.y = coords.y - panStartPoint.y; updateTransform(); } else if (activeDrag) { dragCharacterMove(e); } }
        function onPointerUp(e) { if (isPinching && (!e.touches || e.touches.length < 2)) { isPinching = false; } if (isPanning) { isPanning = false; canvasContainer.style.cursor = 'grab'; } if (activeDrag) dragCharacterEnd(); }
        canvasContainer.addEventListener('wheel', (e) => { e.preventDefault(); const rect = canvasContainer.getBoundingClientRect(); const mouseX = e.clientX - rect.left; const mouseY = e.clientY - rect.top; const zoomFactor = 1.1; const oldScale = scale; scale = e.deltaY < 0 ? scale * zoomFactor : scale / zoomFactor; scale = Math.max(MIN_SCALE, Math.min(MAX_SCALE, scale)); pan.x = mouseX - (mouseX - pan.x) * (scale / oldScale); pan.y = mouseY - (mouseY - pan.y) * (scale / oldScale); updateTransform(); }, { passive: false });
        function getPinchDistance(e) { const dx = e.touches[0].clientX - e.touches[1].clientX; const dy = e.touches[0].clientY - e.touches[1].clientY; return Math.sqrt(dx * dx + dy * dy); }
        function getPinchCenter(e) { const rect = canvasContainer.getBoundingClientRect(); return { x: (e.touches[0].clientX + e.touches[1].clientX) / 2 - rect.left, y: (e.touches[0].clientY + e.touches[1].clientY) / 2 - rect.top, }; }
        canvasContainer.addEventListener('mousedown', onPointerDown);
        window.addEventListener('mousemove', onPointerMove);
        window.addEventListener('mouseup', onPointerUp);
        canvasContainer.addEventListener('touchstart', onPointerDown, { passive: false });
        window.addEventListener('touchmove', onPointerMove, { passive: false });
        window.addEventListener('touchend', onPointerUp);
        window.addEventListener('touchcancel', onPointerUp);
        
        // --- Character Creation & List (unchanged) ---
        function showToast(message){ toastMessage.textContent = message; toast.classList.add('show'); setTimeout(() => { toast.classList.remove('show'); }, 3000); }
        charImageInput.addEventListener('change', () => { fileNameSpan.textContent = charImageInput.files.length > 0 ? charImageInput.files[0].name : 'لم يتم اختيار ملف'; });
        addCharacterForm.addEventListener('submit', (e) => { e.preventDefault(); const name = charNameInput.value; const color = charColorInput.value; const imageFile = charImageInput.files[0]; if (!name || !imageFile) { showToast("الرجاء إدخال اسم واختيار صورة للشخصية."); return; } const reader = new FileReader(); reader.onload = (event) => { characters.push({ id: Date.now(), name: name, color: color, imageUrl: event.target.result }); renderCharacterList(); addCharacterForm.reset(); fileNameSpan.textContent = 'لم يتم اختيار ملف'; document.querySelector('details').open = false; }; reader.readAsDataURL(imageFile); });
        function renderCharacterList(){ characterList.innerHTML = ''; if (characters.length === 0) { characterList.appendChild(emptyListMsg); return; } characters.forEach(char => { const charDiv = document.createElement('div'); charDiv.className = 'flex flex-col items-center gap-1 character-list-item w-20 flex-shrink-0'; charDiv.draggable = true; charDiv.dataset.characterId = char.id; const img = document.createElement('img'); img.src = char.imageUrl; img.className = 'w-16 h-16 rounded-full object-cover border-2'; img.style.borderColor = char.color; const nameSpan = document.createElement('span'); nameSpan.className = 'text-xs text-center truncate w-full'; nameSpan.textContent = char.name; charDiv.appendChild(img); charDiv.appendChild(nameSpan); charDiv.addEventListener('dragstart', (e) => e.dataTransfer.setData('text/plain', char.id)); charDiv.addEventListener('touchstart', (e) => { e.preventDefault(); startListDrag(e, charDiv, char.id); }, { passive: false }); characterList.appendChild(charDiv); }); }
        
        // --- Drag and Drop to Canvas (updated) ---
        canvasContainer.addEventListener('dragover', (e) => e.preventDefault());
        canvasContainer.addEventListener('drop', (e) => { e.preventDefault(); const charId = e.dataTransfer.getData('text/plain'); const character = characters.find(c => c.id == charId); if (!character) return; const containerRect = canvasContainer.getBoundingClientRect(); const x = (e.clientX - containerRect.left - pan.x) / scale; const y = (e.clientY - containerRect.top - pan.y) / scale; createCharacterOnCanvas(character, x, y); });

        function createCharacterOnCanvas(character, x, y) {
            const charElement = document.createElement('div');
            charElement.className = 'character-on-canvas';
            
            const snappedCenterY = Math.round((y) / SHELF_HEIGHT) * SHELF_HEIGHT;
            const snappedTop = snappedCenterY - CHARACTER_HALF_SIZE;
            
            charElement.style.left = `${x - CHARACTER_HALF_SIZE}px`;
            charElement.style.top = `${snappedTop}px`;
            charElement.dataset.color = character.color;
            
            const img = document.createElement('img');
            img.src = character.imageUrl;
            img.style.borderColor = character.color;

            charElement.appendChild(img);
            canvas.appendChild(charElement);

            charElement.addEventListener('mousedown', (e) => dragCharacterStart(e, charElement));
            charElement.addEventListener('touchstart', (e) => dragCharacterStart(e, charElement), { passive: false });
        }
        
        // --- Mobile Drag from List (unchanged) ---
        function startListDrag(e, element, charId) { const ghost = element.cloneNode(true); ghost.id = 'ghost-element'; document.body.appendChild(ghost); const coords = getEventCoords(e); ghost.style.left = `${coords.x - ghost.offsetWidth / 2}px`; ghost.style.top = `${coords.y - ghost.offsetHeight / 2}px`; listDrag = { ghost, charId }; window.addEventListener('touchmove', moveListDrag, { passive: false }); window.addEventListener('touchend', endListDrag, { once: true }); }
        function moveListDrag(e) { if (!listDrag) return; e.preventDefault(); const coords = getEventCoords(e); listDrag.ghost.style.left = `${coords.x - listDrag.ghost.offsetWidth / 2}px`; listDrag.ghost.style.top = `${coords.y - listDrag.ghost.offsetHeight / 2}px`; }
        function endListDrag(e) { if (!listDrag) return; window.removeEventListener('touchmove', moveListDrag); listDrag.ghost.remove(); const touch = e.changedTouches[0]; const dropTarget = document.elementFromPoint(touch.clientX, touch.clientY); if (dropTarget === canvasContainer) { const character = characters.find(c => c.id == listDrag.charId); if (character) { const containerRect = canvasContainer.getBoundingClientRect(); const x = (touch.clientX - containerRect.left - pan.x) / scale; const y = (touch.clientY - containerRect.top - pan.y) / scale; createCharacterOnCanvas(character, x, y); } } listDrag = null; }

        // --- Initial Render ---
        renderCharacterList();
        updateTransform();
    });
</script>

</body>
</html>

